{"meta":{"title":"牧诗的博客","subtitle":"技术总结、心得体会","description":"Back with silence.","author":"牧诗","url":"https://auner.top","root":"/"},"pages":[{"title":"","date":"2020-11-13T11:23:22.548Z","updated":"2020-11-13T11:23:22.548Z","comments":true,"path":"404.html","permalink":"https://auner.top/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"关于我","date":"2020-11-16T02:45:18.000Z","updated":"2020-11-16T02:46:33.057Z","comments":true,"path":"about/index.html","permalink":"https://auner.top/about/index.html","excerpt":"","text":"没啥好介绍的，菜鸟程序员一枚，努力进步。"},{"title":"标签","date":"2020-11-12T03:35:42.000Z","updated":"2020-11-12T15:29:43.294Z","comments":false,"path":"tags/index.html","permalink":"https://auner.top/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-11-12T10:30:22.000Z","updated":"2020-11-12T16:07:14.688Z","comments":false,"path":"categories/index.html","permalink":"https://auner.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 模块","slug":"jsmodule","date":"2020-11-18T05:18:50.000Z","updated":"2020-11-18T05:24:01.230Z","comments":true,"path":"archives/3dcc1b8.html","link":"","permalink":"https://auner.top/archives/3dcc1b8.html","excerpt":"现代 JavaScript 开发需要使用到很多的第三方的库，但是在 ES6 以前 JavaScript 并不支持 module 这一特性。解决这个问题的方案通常是把代码分成很多部分，再通过某些方式将它们连接起来。","text":"现代 JavaScript 开发需要使用到很多的第三方的库，但是在 ES6 以前 JavaScript 并不支持 module 这一特性。解决这个问题的方案通常是把代码分成很多部分，再通过某些方式将它们连接起来。 早期模块系统对象写法123456789var module1 = new Object(&#123; _count: 0, m1: function() &#123; //... &#125;, m2: function() &#123; //... &#125;&#125;) 这样的写法缺点是会暴露内部状态，类似于 module1._count 这样的用法。 立即执行函数写法使用立即执行函数（Immediately-Invoked Function Express, IIFE）写法可以不暴露私有成员的目的。 12345678910111213var module = (function() &#123; _count = 0 m1: function() &#123; //... &#125; m2: function() &#123; //... &#125; return &#123; m1:m1, m2:m2 &#125;&#125;)() 使用上面这个写法，外部代码访问不到内部的变量。 ES6 前主流模块规范CommonJS规范CommonJS 规范概述了同步声明依赖的模块定义。这个规范主要用于在服务器端实现模块化代码组织，但也可定义在浏览器中使用的模块依赖。需要注意的是 CommonJS 模块语法不能直接在浏览器中使用。 Node.js 中使用了 CommonJS 规范。 CommonJS 模块定义需要使用 require() 指定依赖，而使用 exports 对象定义自己的公共 API。下面的代码展示了简单的模块定义： 12345var moduleB = require(&#x27;./moduleB&#x27;);module.exports = &#123; stuff: moduleB.doStuff();&#125;; moduleA 通过使用模块定义的相对路径来指定自己对 moduleB 的依赖。什么是「模块定义」以及如何将字符串解析为模块，完全取决于模块系统的实现。 请求模块会加载相应的模块，可以选择是否将模块赋值给变量。如果不赋值给变量，调用 require() 会把模块原封不动地加载进来。 无论一个模块在 require() 中被引用多少次，模块永远是单例的，看下面的例子： 1234var a1 = require(&#x27;./moduleA&#x27;);var a2 = require(&#x27;./moduleA&#x27;);console.log(a1 === a2); // true 在 CommonJS 中，模块加载是模块系统执行的同步操作,因此 require() 可以像下面的方式嵌入模块中： 123if (loadCondition) &#123; require(&#x27;./moduleA&#x27;)&#125; 这里的 moduleA 只会在 loadCondition 为 true 时才会加载。这个加载是同步的，因此 if 之前所有的代码都会在加载 moduleA 之前执行，而 if 之后的代码都会在加载 moduleA 之后执行。同样，加载顺序规则也适用。如果之前已经加载过 moduleA 模块，之后再调用就只是暴露命名空间。 moduleA 在 module.exports 对象上定义自己的公共接口，即 foo 属性。如果有模块想使用该接口，可以如下操作： 12var moduleA = require(&#x27;./moduleA&#x27;)moduleA.foo 即使一个模块没有任何公共的接口，如果应用程序请求了该模块，那么也会在加载的时候执行该模块体。 module.exports 对象非常灵活，有多种使用方式。如果只想导出一个实体，可以直接给 module.exports 赋值： 1module.exports = &#x27;foo&#x27; 导出多个值也很常见，可以使用对象字面量赋值或每个属性赋一次值来实现： 1234567module.exports = &#123; a: &#x27;A&#x27;, b: &#x27;B&#x27;&#125;module.exports.a = &#x27;A&#x27;;module.exports.b = &#x27;B&#x27;; 上述两种定义风格是等价的。 模块的一个主要用途是托管类定义（这里使用 ES6 风格的类定义，不过 ES5 风格也兼容）： 123456class A &#123;&#125;module.exports = A;var A = require(&#x27;./moduleA&#x27;);var a = new A(); 也可以将类实例作为导出值： 12class A &#123;&#125;module.exports = new A(); 此外，CommonJS 也支持动态依赖： 123if (condition) &#123; var A = require(&#x27;./moduleA&#x27;);&#125; AMD 规范CommonJS 以服务器端为目标环境，能够一次性把所有模块都加载到内存，而异步模块定义（AMD, Asynchronous Module Definition）的模块定义系统则以浏览器为目标执行环境，这需要考虑网络延迟的问题。AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。 AMD 模块的核心是用函数包装模块定义，好处是可以防止声明全局变量，而且允许加载器库自行决定何时加载模块。包装模块的函数是全局 define 的参数，它是由 AMD 加载器库的实现定义的。 1234567// ID 为 &#x27;moduleA&#x27; 的模块定义。moduleA 依赖 moduleB，// moduleB 会异步加载define(&#x27;moduleA&#x27;, [&#x27;moduleB&#x27;], function(moduleB) &#123; return &#123; stuff: moduleB.doStuff(); &#125;;&#125;); ES6 规范ES6 最大的改进就是引入了模块规范。有了 ES6 的模块规范，CommonJS 和 AMD规范都不再必要了。 模块标签给 script 标签添加 module 属性，代表引入的 JavaScript 文件是作为一个模块执行，而不是作为传统的脚本执行。解析到 &lt;script type=&quot;module&quot;&gt; 标签后会立即下载该模块文件，但执行会延迟到文档解析完成。&lt;script type=&quot;module&quot;&gt; 在文件中的顺序就是他们执行的顺序，改变其位置只会影响文件加载时机，不会改变模块加载时机。 与 &lt;script type=&quot;module&quot;&gt; 模块标签相关联的模块被认为是入口模块。一个页面有多少入口模块没有限制，同一个模块被加载多少次也无限制。同一个模块在页面中无论被加载多少次，也不管用什么方式加载，只会加载一次。 12345678910// moduleA只会加载一次&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; import &#x27;./moduleA.js&#x27;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; import &#x27;./moduleA.js&#x27;&lt;/script&gt; 模块加载ES6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。部分浏览器没有原生支持 ES6 模块，因此可能还需要第三方工具。 完全支持 ES6 模块的浏览器可以从顶级模块加载整个依赖图，而且是异步完成的。浏览器首先解析入口模块，确定它们的依赖，并发送对依赖模块的请求。这些依赖模块返回后，浏览器解析这些依赖模块，确定它们的依赖，再对它们的依赖发送请求。直到所有的依赖都解析完成，应用程序正式加载模块。 模块行为（特性） 模块代码只在加载后执行。 模块只能加载一次。 模块是单例的。 模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。 模块可以请求加载其他模块。 支持循环依赖。 ES6 模块默认在严格模式下执行。 ES6 模块不共享全局命名空间。 模块顶级 this 的值是 undefined。 模块中的 var 声明不会添加到 window 对象。 ES6 模块是异步加载和执行的。 模块导出export 有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。 12345678910111213export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, constexport default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …; 外部模块可以导入这个模块，而foo将成为这个导入模块的一个属性 1export const foo = &#x27;foo&#x27;; 变量声明和导出可以不在一行，在 export 子句中执行声明并将其导出到其他地方 12var foo = &#x27;foo&#x27;;export &#123; foo &#125;; 导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。因此，声明值、导出值和为导出值提供别名不能在一行完成。导入的模块可以使用 myFoo 来访问其导出的值 12const foo = &#x27;foo&#x27;;export &#123; foo as myFoo &#125;; 考虑到导出多个值是常见的操作，ES6 模块也支持对导出声明分组，可以同时为部分或全部导出值指定别名： 1234const foo = &#x27;foo&#x27;;const bar = &#x27;bar&#x27;;const baz = &#x27;baz&#x27;;export &#123; foo, bar as myBar, baz &#125;; 默认导出（default export）就好像模块与被导出的值是一回事。默认导出使用 default 关键字将一个值声明为默认导出，每个模块只能有一个默认导出。重复的默认导出会导致 SyntaxError 。 12const foo = &#x27;foo&#x27;;export default foo; 上段代码也可以写成这样： 12const foo = &#x27;foo&#x27;;export &#123; foo as default &#125; 模块导入import 必须出现在模块的顶级 1234567// 允许import ...// 不允许if (loadCondition) &#123; import ...&#125; 不过 import 的相对位置并不重要，import 语句会被提升到模块顶部。 123console.log(foo)import &#123; foo &#125; from &#x27;./moduleA.js&#x27; 花括号中的变量与后面模块中 export 的变量保持一致。 12import &#123; foo &#125; from &quot;module&quot;;import &#123; foo, bar &#125; from &quot;module&quot;; 也可以为导入的变量指定别名 1import &#123; foo as myFoo &#125; from &#x27;module&#x27; 命名导出可以使用 * 批量获取并赋值给保存导出集合的别名，而无须列出每个标识符： 123456const foo = &#x27;foo&#x27;, bar = &#x27;bar&#x27;, baz = &#x27;baz&#x27;;export &#123; foo, bar, baz &#125;import * as Foo from &#x27;./foo.js&#x27;;console.log(Foo.foo); // fooconsole.log(Foo.bar); // barconsole.log(Foo.baz); // baz 默认导出就好像整个模块就是导出的值一样。可以使用 default 关键字并提供别名来导入。也可以不使用大括号，此时指定的标识符就是默认导出的别名： 123// 等效import &#123; default as foo &#125; from &#x27;./foo.js&#x27;;import foo from &#x27;./foo.js&#x27;; 如果模块同时导出了命名导出和默认导出，则可以在 import 语句中同时导入它们。可以依次列出特定导出的标识符来取得，也可以使用 * 来取得： 123import foo, &#123; bar, baz &#125; from &#x27;./foo.js&#x27;;import &#123; default as foo, bar, baz &#125; from &#x27;./foo.js&#x27;;import foo, * as Foo from &#x27;./foo.js&#x27;;","categories":[{"name":"前端","slug":"前端","permalink":"https://auner.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://auner.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]}